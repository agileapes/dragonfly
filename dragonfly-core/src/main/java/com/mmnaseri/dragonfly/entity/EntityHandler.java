/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 Milad Naseri.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package com.mmnaseri.dragonfly.entity;

import com.mmnaseri.dragonfly.data.DataAccess;
import com.mmnaseri.dragonfly.data.DataAccessSession;
import com.mmnaseri.dragonfly.data.impl.ManyToManyMiddleEntity;
import com.mmnaseri.dragonfly.error.NoPrimaryKeyDefinedError;
import com.mmnaseri.dragonfly.metadata.RelationMetadata;
import com.mmnaseri.dragonfly.metadata.TableMetadata;

import java.io.Serializable;
import java.util.Map;
import java.util.Set;

/**
 * This interface encapsulates all the information about an entity that can be known
 * beforehand.
 *
 * @author Milad Naseri (mmnaseri@programmer.net)
 * @since 1.0 (2013/9/14, 4:49)
 */
public interface EntityHandler<E> {

    /**
     * @return the type of the supported entity
     */
    Class<E> getEntityType();

    /**
     * Populates a map from the given entity's properties such that all properties set
     * on the entity are reflected back in the map. Here, the map's keys will be property
     * names.
     * @param entity    the entity to create the map from
     * @return the populated map
     */
    Map<String, Object> toMap(E entity);

    /**
     * Populates the properties of a given entity based on the provided map. Keep in mind
     * that here, the map's keys are column names.
     * @param entity    the entity to be populated
     * @param map       the map to read from
     * @return populated entity (same instance as the input)
     */
    E fromMap(E entity, Map<String, Object> map);

    /**
     * Returns the current value set for the key property on the given entity, or throws
     * an exception if no key has been defined.
     * @param entity    the entity to read the key from
     * @return the value of the key
     * @throws NoPrimaryKeyDefinedError
     */
    Serializable getKey(E entity);

    /**
     * Changes the value of the key property for the entity, or throws an exception if no
     * key has been defined.
     * @param entity    the entity to write the value to
     * @param key       the new value for the key
     * @throws NoPrimaryKeyDefinedError
     */
    void setKey(E entity, Serializable key);

    /**
     * Determines whether or not a key property has been defined for the entity
     * @return {@code true} means there is a key property
     */
    boolean hasKey();

    /**
     * Determines whether or not the key for the entity is auto-generated or not or throws
     * an exception in case there are no key columns
     * @return {@code true} means that the database system will generate values for the
     * key property
     * @throws NoPrimaryKeyDefinedError
     */
    boolean isKeyAutoGenerated();

    /**
     * Copies the properties of the first entity into the second entity
     * @param original    the entity to read from
     * @param copy        the entity to write to
     */
    void copy(E original, E copy);

    /**
     * @return the name of the key property for the entity
     * @throws NoPrimaryKeyDefinedError
     */
    String getKeyProperty();

    /**
     * Loads all eager relations into the entity
     * @param entity                   the entity to be loaded
     * @param values                   the values of the actual data retrieval
     * @param initializationContext    the initialization context for the entity
     */
    void loadEagerRelations(E entity, Map<String, Object> values, EntityInitializationContext initializationContext);

    /**
     * Loads the given lazy relation into the entity
     * @param entity               the entity
     * @param relationMetadata    the lazy relation
     * @param dataAccess           the data access through which the relations should be loaded
     * @param entityContext        the context which holds entities
     * @param map                  the map of the entity's loaded values
     * @param session              the session through which connections can be made
     */
    void loadLazyRelation(E entity, RelationMetadata<E, ?> relationMetadata, DataAccess dataAccess, EntityContext entityContext, Map<String, Object> map, DataAccessSession session);

    /**
     * Deletes all objects on the deletion of which the correct deletion of
     * the entity relies
     * @param entity        the entity that is to be deleted
     * @param dataAccess    the data access for the deletion
     */
    void deleteDependencyRelations(E entity, DataAccess dataAccess);

    /**
     * Deletes all objects that are references by the given entity
     * @param entity        the entity that is to be deleted
     * @param dataAccess    the data access for the deletion
     */
    void deleteDependentRelations(E entity, DataAccess dataAccess);

    /**
     * Saves all relations to which references exist in the given entity
     * @param entity        the entity that is to be saved
     * @param dataAccess    the data access for the save
     */
    void saveDependencyRelations(E entity, DataAccess dataAccess);

    /**
     * Saves all relations which refer to the entity
     * @param entity        the entity that is to be saved
     * @param dataAccess    the data access for the save
     * @param entityContext the context through which the entity was initialized
     */
    void saveDependentRelations(E entity, DataAccess dataAccess, EntityContext entityContext);

    /**
     * Returns a map of all related many-to-many objects with table metadata for each relation
     * as the key
     * @param entity    the entity instance for which the relations must be extracted
     * @return the map of related objects
     */
    Map<TableMetadata<?>, Set<ManyToManyMiddleEntity>> getManyToManyRelatedObjects(E entity);

    /**
     * Advances the version of the entity by one, if applicable
     * @param entity    the entity for which the version must be advanced
     */
    void incrementVersion(E entity);

    /**
     * Initializes the version value for the version column of the given entity, if applicable
     * @param entity    the entity for which the version must be advanced
     */
    void initializeVersion(E entity);

    /**
     * Determines whether or not the entity is lockable. At the moment, this is the same as
     * checking for optimistic locking support for the entity
     * @return {@code true} means the entity is lockable
     */
    boolean isLockable();

    /**
     * Returns the version for the entity
     * @param entity    the entity for which the version must be evaluated
     * @return the version for the entity
     */
    Serializable getVersion(E entity);

    /**
     * Sets the version for the entity
     * @param entity     the entity for which the version must be evaluated
     * @param version    the version for the entity
     */
    void setVersion(E entity, Serializable version);

}
