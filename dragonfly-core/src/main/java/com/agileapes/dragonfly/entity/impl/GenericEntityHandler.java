/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 AgileApes, Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package com.agileapes.dragonfly.entity.impl;

import com.mmnaseri.couteau.basics.api.Filter;
import com.mmnaseri.couteau.basics.api.Processor;
import com.mmnaseri.couteau.basics.api.impl.NegatingFilter;
import com.mmnaseri.couteau.context.error.RegistryException;
import com.mmnaseri.couteau.reflection.beans.BeanAccessor;
import com.mmnaseri.couteau.reflection.beans.BeanWrapper;
import com.mmnaseri.couteau.reflection.beans.impl.MethodBeanAccessor;
import com.mmnaseri.couteau.reflection.beans.impl.MethodBeanWrapper;
import com.mmnaseri.couteau.reflection.error.NoSuchPropertyException;
import com.mmnaseri.couteau.reflection.property.WritePropertyAccessor;
import com.mmnaseri.couteau.reflection.util.ReflectionUtils;
import com.agileapes.dragonfly.data.DataAccess;
import com.agileapes.dragonfly.data.DataAccessSession;
import com.agileapes.dragonfly.data.impl.ManyToManyActionHelper;
import com.agileapes.dragonfly.data.impl.ManyToManyMiddleEntity;
import com.agileapes.dragonfly.entity.EntityContext;
import com.agileapes.dragonfly.entity.EntityHandler;
import com.agileapes.dragonfly.entity.EntityInitializationContext;
import com.agileapes.dragonfly.entity.InitializedEntity;
import com.agileapes.dragonfly.error.*;
import com.agileapes.dragonfly.metadata.*;
import com.agileapes.dragonfly.metadata.impl.PrimaryKeyConstraintMetadata;
import com.agileapes.dragonfly.statement.impl.DefaultStatementPreparator;
import com.agileapes.dragonfly.tools.ColumnNameFilter;
import com.agileapes.dragonfly.tools.ColumnPropertyFilter;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.*;

import static com.mmnaseri.couteau.basics.collections.CollectionWrapper.with;

/**
 * This generic entity handler is capable of handling all operations expected from an entity handler
 * and moreover it can do it all for any and all entities of all types. This not being tailored for
 * one specific entity type makes it somewhat slower, as it needs to determine the how of doing
 * everything at runtime, instead of having the knowledge intrinsically.
 *
 * @author Mohammad Milad Naseri (m.m.naseri@gmail.com)
 * @since 1.0 (2013/9/18, 15:28)
 */
public class GenericEntityHandler<E> implements EntityHandler<E> {

    private final Class<E> entityType;
    private final DefaultEntityMapCreator mapCreator;
    private final DefaultMapEntityCreator entityCreator;
    private final EntityContext entityContext;
    private final TableMetadata<E> tableMetadata;
    private boolean keyAutoGenerated;
    private boolean hasPrimaryKey;
    private String keyProperty;

    public GenericEntityHandler(Class<E> entityType, EntityContext entityContext, TableMetadata<E> tableMetadata) {
        this.entityType = entityType;
        this.entityContext = entityContext;
        this.tableMetadata = tableMetadata;
        mapCreator = new DefaultEntityMapCreator();
        try {
            entityCreator = new DefaultMapEntityCreator();
        } catch (RegistryException e) {
            throw new RuntimeException(e);
        }
        hasPrimaryKey = this.tableMetadata.hasPrimaryKey();
        if (hasPrimaryKey) {
            final PrimaryKeyConstraintMetadata primaryKey = this.tableMetadata.getPrimaryKey();
            if (primaryKey.getColumns().size() != 1) {
                hasPrimaryKey = false;
            } else {
                final ColumnMetadata columnMetadata = primaryKey.getColumns().iterator().next();
                keyProperty = columnMetadata.getPropertyName();
                keyAutoGenerated = ValueGenerationType.IDENTITY.equals(columnMetadata.getGenerationType());
            }
        }
    }

    @Override
    public Class<E> getEntityType() {
        return entityType;
    }

    @Override
    public Map<String, Object> toMap(E entity) {
        return mapCreator.toMap(tableMetadata, entity);
    }

    @Override
    public E fromMap(E entity, final Map<String, Object> map) {
        return entityCreator.fromMap(entity, tableMetadata.getColumns(), map);
    }

    @Override
    public Serializable getKey(E entity) {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        try {
            return new MethodBeanAccessor<E>(entity).getPropertyValue(keyProperty, Serializable.class);
        } catch (Exception e) {
            return null;
        }
    }

    @Override
    public void setKey(E entity, Serializable key) {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        try {
            new MethodBeanWrapper<E>(entity).setPropertyValue(keyProperty, key);
        } catch (Exception e) {
            throw new EntityDefinitionError("Failed to set key on entity " + entityType, e);
        }
    }

    @Override
    public boolean hasKey() {
        return hasPrimaryKey;
    }

    @Override
    public boolean isKeyAutoGenerated() {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        return keyAutoGenerated;
    }

    @Override
    public void copy(E original, E copy) {
        if (original instanceof InitializedEntity) {
            ((InitializedEntity) original).freeze();
        }
        final BeanAccessor<E> reader = new MethodBeanAccessor<E>(original);
        final BeanWrapper<E> writer = new MethodBeanWrapper<E>(copy);
        //noinspection unchecked
        with(reader.getPropertyNames())
                .keep(new Filter<String>() {
                    @Override
                    public boolean accepts(String item) {
                        try {
                            return writer.isWritable(item);
                        } catch (NoSuchPropertyException e) {
                            return false;
                        }
                    }
                })
                .each(new Processor<String>() {
                    @Override
                    public void process(String input) {
                        try {
                            writer.setPropertyValue(input, reader.getPropertyValue(input));
                        } catch (Exception ignored) {
                        }
                    }
                });
        if (original instanceof InitializedEntity) {
            ((InitializedEntity) original).unfreeze();
        }
    }

    @Override
    public String getKeyProperty() {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        return keyProperty;
    }

    @Override
    public void loadEagerRelations(final E entity, final Map<String, Object> values, final EntityInitializationContext initializationContext) {
        final MethodBeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .drop(new Filter<RelationMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(RelationMetadata<E, ?> item) {
                        return item.isLazy();
                    }
                })
                .forThose(new Filter<RelationMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(RelationMetadata<E, ?> reference) {
                                  return reference.isOwner() && reference.getType().getForeignCardinality() == 1;
                              }
                          },
                        new Processor<RelationMetadata<E, ?>>() {
                            @Override
                            public void process(final RelationMetadata<E, ?> reference) {
                                final ColumnMetadata columnMetadata = with(reference.getLocalTable().getColumns()).find(new ColumnPropertyFilter(reference.getPropertyName()));
                                final String columnName = with(values.keySet()).find(new Filter<String>() {
                                    @Override
                                    public boolean accepts(String item) {
                                        return item.equalsIgnoreCase(columnMetadata.getName());
                                    }
                                });
                                final Object foreignKey = values.get(columnName);
                                if (foreignKey == null) {
                                    return;
                                }
                                final Object foreignEntity;
                                if (hasKey() && getKey(entity) != null) {
                                    foreignEntity = initializationContext.get(reference.getForeignTable().getEntityType(), (Serializable) foreignKey, getEntityType(), getKey(entity));
                                } else {
                                    foreignEntity = initializationContext.get(reference.getForeignTable().getEntityType(), (Serializable) foreignKey);
                                }
                                try {
                                    wrapper.setPropertyValue(reference.getPropertyName(), foreignEntity);
                                } catch (Exception e) {
                                    throw new EntityPreparationError("Could not set relation property " + reference.getLocalTable().getEntityType().getCanonicalName() + "." + reference.getPropertyName(), e);
                                }
                            }
                        }
                )
                .forThose(new Filter<RelationMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(RelationMetadata<E, ?> reference) {
                                  return !reference.isOwner() && reference.getType().getLocalCardinality() == 1;
                              }
                          }, new Processor<RelationMetadata<E, ?>>() {
                              @Override
                              public void process(RelationMetadata<E, ?> reference) {
                                  final Object foreignEntity = entityContext.getInstance(reference.getForeignTable().getEntityType());
                                  final MethodBeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                                  try {
                                      foreignEntityWrapper.setPropertyValue(reference.getForeignColumn().getPropertyName(), entity);
                                  } catch (Exception e) {
                                      throw new EntityPreparationError("Could not set relation property " + reference.getForeignTable().getEntityType().getCanonicalName() + "." + reference.getForeignColumn().getPropertyName(), e);
                                  }
                                  final List<Object> objects = initializationContext.getDataAccess().find(foreignEntity, reference.getOrdering().toString());
                                  final Object propertyValue;
                                  if (reference.getType().getForeignCardinality() == 1) {
                                      if (objects.isEmpty()) {
                                          return;
                                      } else if (objects.size() > 1) {
                                          throw new RelationDefinitionError("More than one item corresponds to one-to-one relationship");
                                      }
                                      propertyValue = objects.get(0);
                                  } else {
                                      try {
                                          propertyValue = ReflectionUtils.getCollection(wrapper.getPropertyType(reference.getPropertyName()));
                                      } catch (NoSuchPropertyException e) {
                                          throw new RelationDefinitionError("Failed to get property type " + reference.getLocalTable().getEntityType().getCanonicalName() + "." + reference.getPropertyName());
                                      }
                                      //noinspection unchecked
                                      ((Collection<Object>) propertyValue).addAll(objects);
                                  }
                                  try {
                                      wrapper.setPropertyValue(reference.getPropertyName(), propertyValue);
                                  } catch (Exception e) {
                                      throw new EntityPreparationError("Could not set relation property " + reference.getLocalTable().getEntityType().getCanonicalName() + "." + reference.getPropertyName(), e);
                                  }
                              }
                          }
                );
    }

    @Override
    public void loadLazyRelation(E entity, final RelationMetadata<E, ?> relationMetadata, final DataAccess dataAccess, EntityContext entityContext, Map<String, Object> map, DataAccessSession session) {
        final BeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        if (relationMetadata.getType().equals(RelationType.ONE_TO_ONE)) {
            if (relationMetadata.isOwner()) {
                final ColumnMetadata columnMetadata = with(tableMetadata.getColumns()).find(new ColumnPropertyFilter(relationMetadata.getPropertyName()));
                final String key = with(map.keySet()).find(new Filter<String>() {
                    @Override
                    public boolean accepts(String item) {
                        return item.equalsIgnoreCase(columnMetadata.getName());
                    }
                });
                if (!map.containsKey(key) || map.get(key) == null) {
                    return;
                }
                final Object foreignEntity = entityContext.getInstance(relationMetadata.getForeignTable().getEntityType());
                if (!columnMetadata.getForeignReference().getDeclaringClass().isInstance(foreignEntity)) {
                    return;
                }
                final BeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                try {
                    foreignEntityWrapper.setPropertyValue(columnMetadata.getForeignReference().getPropertyName(), map.get(key));
                } catch (Exception e) {
                    throw new EntityPreparationError("Failed to prepare entity properties", e);
                }
                final List<Object> objects = dataAccess.find(foreignEntity);
                if (objects.isEmpty()) {
                    return;
                }
                if (objects.size() > 1) {
                    throw new EntityPreparationError("More than one entity correspond to one-to-one relationship");
                }
                try {
                    wrapper.setPropertyValue(relationMetadata.getPropertyName(), objects.get(0));
                } catch (Exception e) {
                    throw new EntityPreparationError("Failed to prepare entity", e);
                }
            } else {
                final Object foreignEntity = entityContext.getInstance(relationMetadata.getForeignTable().getEntityType());
                final BeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                try {
                    foreignEntityWrapper.setPropertyValue(relationMetadata.getForeignColumn().getPropertyName(), entity);
                } catch (Exception e) {
                    throw new EntityPreparationError("Failed to prepare entity properties", e);
                }
                final List<Object> objects = dataAccess.find(foreignEntity);
                if (objects.isEmpty()) {
                    return;
                }
                if (objects.size() > 1) {
                    throw new EntityPreparationError("More than one entity correspond to one-to-one relationship");
                }
                try {
                    wrapper.setPropertyValue(relationMetadata.getPropertyName(), objects.get(0));
                } catch (Exception e) {
                    throw new EntityPreparationError("Failed to prepare entity", e);
                }
            }
        } else if (relationMetadata.getType().equals(RelationType.ONE_TO_MANY)) {
            final Object foreignEntity = entityContext.getInstance(relationMetadata.getForeignTable().getEntityType());
            final BeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
            try {
                foreignEntityWrapper.setPropertyValue(relationMetadata.getForeignColumn().getPropertyName(), entity);
            } catch (Exception e) {
                throw new EntityPreparationError("Failed to prepare entity properties", e);
            }
            try {
                final Collection<Object> newCollection = ReflectionUtils.getCollection(wrapper.getPropertyType(relationMetadata.getPropertyName()));
                newCollection.addAll(dataAccess.find(foreignEntity, relationMetadata.getOrdering().toString()));
                wrapper.setPropertyValue(relationMetadata.getPropertyName(), newCollection);
            } catch (Exception e) {
                throw new EntityPreparationError("Failed to prepare entity", e);
            }
        } else if (relationMetadata.getType().equals(RelationType.MANY_TO_ONE)) {
            final ColumnMetadata columnMetadata = with(tableMetadata.getColumns()).find(new ColumnPropertyFilter(relationMetadata.getPropertyName()));
            final String key = with(map.keySet()).find(new Filter<String>() {
                @Override
                public boolean accepts(String item) {
                    return item.equalsIgnoreCase(columnMetadata.getName());
                }
            });
            if (!map.containsKey(key) || map.get(key) == null) {
                return;
            }
            final Object foreignEntity = entityContext.getInstance(relationMetadata.getForeignTable().getEntityType());
            if (!columnMetadata.getForeignReference().getDeclaringClass().isInstance(foreignEntity)) {
                return;
            }
            final BeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
            try {
                foreignEntityWrapper.setPropertyValue(columnMetadata.getForeignReference().getPropertyName(), map.get(key));
            } catch (Exception e) {
                throw new EntityPreparationError("Failed to prepare entity properties", e);
            }
            final List<Object> objects = dataAccess.find(foreignEntity);
            if (objects.isEmpty()) {
                return;
            }
            if (objects.size() > 1) {
                throw new EntityPreparationError("More than one entity correspond to one-to-one relationship");
            }
            try {
                wrapper.setPropertyValue(relationMetadata.getPropertyName(), objects.get(0));
            } catch (Exception e) {
                throw new EntityPreparationError("Failed to prepare entity", e);
            }
        } else if (relationMetadata.getType().equals(RelationType.MANY_TO_MANY)) {
            final Connection connection = session.getConnection();
            final ManyToManyActionHelper helper = new ManyToManyActionHelper(new DefaultStatementPreparator(false), connection, session.getDatabaseDialect().getStatementBuilderContext(), relationMetadata.getForeignColumn().getTable(), tableMetadata, relationMetadata, entityContext);
            final ManyToManyMiddleEntity middleEntity = new ManyToManyMiddleEntity();
            final BeanWrapper<ManyToManyMiddleEntity> middleEntityWrapper = new MethodBeanWrapper<ManyToManyMiddleEntity>(middleEntity);
            try {
                middleEntityWrapper.setPropertyValue(relationMetadata.getForeignColumn().getPropertyName(), entity);
            } catch (Exception e) {
                throw new EntityPreparationError("Failed to prepare entity", e);
            }
            //look up lazy foreign relations
            final List<Object> list = helper.find(middleEntity, null, null);
            helper.close();
            try {
                connection.close();
            } catch (SQLException e) {
                throw new EntityPreparationError("Failed to commit changes to the database", e);
            }
            try {
                wrapper.setPropertyValue(relationMetadata.getPropertyName(), list);
            } catch (Exception e) {
                throw new EntityPreparationError("Failed to prepare entity", e);
            }
        }
    }

    @Override
    public void deleteDependentRelations(final E entity, final DataAccess dataAccess) {
        final MethodBeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .keep(new Filter<RelationMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(RelationMetadata<E, ?> item) {
                        return item.getCascadeMetadata().cascadeRemove();
                    }
                })
                .forThose(new Filter<RelationMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(RelationMetadata<E, ?> item) {
                                  return item.isOwner();
                              }
                          }, new Processor<RelationMetadata<E, ?>>() {
                              @Override
                              public void process(RelationMetadata<E, ?> reference) {
                                  //many-to-one, owner=here and one-to-one, owner=here
                                  try {
                                      final Object foreignEntity = wrapper.getPropertyValue(reference.getPropertyName());
                                      if (foreignEntity == null) {
                                          return;
                                      }
                                      dataAccess.delete(foreignEntity);
                                  } catch (Exception e) {
                                      throw new EntityDefinitionError("Could not access foreign property", e);
                                  }
                              }
                          }
                );
    }

    @Override
    public void deleteDependencyRelations(final E entity, final DataAccess dataAccess) {
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .keep(new Filter<RelationMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(RelationMetadata<E, ?> item) {
                        return item.getCascadeMetadata().cascadeRemove();
                    }
                })
                .forThose(new Filter<RelationMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(RelationMetadata<E, ?> item) {
                                  return !item.isOwner() && item.getType().getLocalCardinality() == 1;
                              }
                          },
                        new Processor<RelationMetadata<E, ?>>() {
                            @Override
                            public void process(RelationMetadata<E, ?> reference) {
                                //one-to-many, owner=there and one-to-one, owner=there
                                final Object foreignEntity = entityContext.getInstance(reference.getForeignTable().getEntityType());
                                final MethodBeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                                try {
                                    //noinspection unchecked
                                    final WritePropertyAccessor<Object> writer = (WritePropertyAccessor<Object>) foreignEntityWrapper.getPropertyWriter(reference.getForeignColumn().getPropertyName());
                                    writer.setPropertyValue(entity);
                                } catch (Exception e) {
                                    throw new EntityDefinitionError("Failed to access property", e);
                                }
                                dataAccess.delete(foreignEntity);
                            }
                        }
                );
    }

    @Override
    public void saveDependencyRelations(E entity, final DataAccess dataAccess) {
        final MethodBeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .keep(new Filter<RelationMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(RelationMetadata<E, ?> item) {
                        return item.getCascadeMetadata().cascadePersist() && item.isOwner();
                    }
                })
                .forThose(new Filter<RelationMetadata<E, ?>>() {
                              //many-to-one and one-to-one relations where owner=here
                              @Override
                              public boolean accepts(RelationMetadata<E, ?> item) {
                                  return item.getType().getForeignCardinality() == 1;
                              }
                          },
                        new Processor<RelationMetadata<E, ?>>() {
                            @Override
                            public void process(RelationMetadata<E, ?> input) {
                                try {
                                    final Object foreignEntity = wrapper.getPropertyValue(input.getPropertyName());
                                    if (foreignEntity == null) {
                                        return;
                                    }
                                    wrapper.setPropertyValue(input.getPropertyName(), dataAccess.save(foreignEntity));
                                } catch (Exception e) {
                                    throw new EntityDefinitionError("Failed to access property " + input.getLocalTable().getEntityType().getCanonicalName() + "." + input.getPropertyName(), e);
                                }
                            }
                        }
                );
    }

    @Override
    public void saveDependentRelations(final E entity, final DataAccess dataAccess, final EntityContext entityContext) {
        final MethodBeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .keep(new Filter<RelationMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(RelationMetadata<E, ?> item) {
                        return item.getCascadeMetadata().cascadePersist() && !item.isOwner();
                    }
                })
                .forThose(new Filter<RelationMetadata<E, ?>>() {
                              //one-to-one relations
                              @Override
                              public boolean accepts(RelationMetadata<E, ?> item) {
                                  //one-to-one
                                  return item.getType().getLocalCardinality() == 1 && item.getType().getForeignCardinality() == 1;
                              }
                          },
                        new Processor<RelationMetadata<E, ?>>() {
                            @Override
                            public void process(RelationMetadata<E, ?> reference) {
                                try {
                                    final Object foreignEntitySample = entityContext.getInstance(reference.getForeignColumn().getTable().getEntityType());
                                    final MethodBeanWrapper<Object> foreignEntitySampleWrapper = new MethodBeanWrapper<Object>(foreignEntitySample);
                                    foreignEntitySampleWrapper.setPropertyValue(reference.getForeignColumn().getPropertyName(), entity);
                                    dataAccess.delete(foreignEntitySample);
                                    final Object foreignEntity = wrapper.getPropertyValue(reference.getPropertyName());
                                    if (foreignEntity == null) {
                                        return;
                                    }
                                    final MethodBeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                                    foreignEntityWrapper.setPropertyValue(reference.getForeignColumn().getPropertyName(), entity);
                                    wrapper.setPropertyValue(reference.getPropertyName(), dataAccess.save(foreignEntity));
                                } catch (Exception e) {
                                    throw new EntityDefinitionError("Failed to access property " + reference.getLocalTable().getEntityType().getCanonicalName() + "." + reference.getPropertyName(), e);
                                }
                            }
                        }
                )
                .forThose(new Filter<RelationMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(RelationMetadata<E, ?> item) {
                                  //one-to-many
                                  return item.getType().getLocalCardinality() == 1 && item.getType().getForeignCardinality() > 1;
                              }
                          },
                        new Processor<RelationMetadata<E, ?>>() {
                            @Override
                            public void process(RelationMetadata<E, ?> reference) {
                                try {
                                    final Object foreignEntitySample = entityContext.getInstance(reference.getForeignColumn().getTable().getEntityType());
                                    final MethodBeanWrapper<Object> foreignEntitySampleWrapper = new MethodBeanWrapper<Object>(foreignEntitySample);
                                    foreignEntitySampleWrapper.setPropertyValue(reference.getForeignColumn().getPropertyName(), entity);
                                    dataAccess.delete(foreignEntitySample);
                                    final Object propertyValue = wrapper.getPropertyValue(reference.getPropertyName());
                                    if (propertyValue == null) {
                                        return;
                                    }
                                    //noinspection unchecked
                                    final Collection<Object> originalCollection = (Collection<Object>) propertyValue;
                                    final Collection<Object> newCollection = ReflectionUtils.getCollection(originalCollection.getClass());
                                    for (Object foreignEntity : originalCollection) {
                                        if (foreignEntity == null) {
                                            newCollection.add(null);
                                            continue;
                                        }
                                        final MethodBeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                                        foreignEntityWrapper.setPropertyValue(reference.getForeignColumn().getPropertyName(), entity);
                                        newCollection.add(dataAccess.save(foreignEntity));
                                    }
                                    wrapper.setPropertyValue(reference.getPropertyName(), newCollection);
                                } catch (Exception e) {
                                    throw new EntityDefinitionError("Failed to access property " + reference.getLocalTable().getEntityType().getCanonicalName() + "." + reference.getPropertyName(), e);
                                }
                            }
                        }
                )
                .forThose(
                        new Filter<RelationMetadata<E, ?>>() {
                            @Override
                            public boolean accepts(RelationMetadata<E, ?> item) {
                                return item.getType().getLocalCardinality() > 1 && item.getType().getForeignCardinality() > 1;
                            }
                        },
                        new Processor<RelationMetadata<E, ?>>() {
                            @Override
                            public void process(RelationMetadata<E, ?> reference) {
                                try {
                                    final Object propertyValue = wrapper.getPropertyValue(reference.getPropertyName());
                                    if (propertyValue == null) {
                                        return;
                                    }
                                    //noinspection unchecked
                                    final Collection<Object> originalCollection = (Collection<Object>) propertyValue;
                                    if (originalCollection.isEmpty()) {
                                        return;
                                    }
                                    final Class<?> collectionType = wrapper.getPropertyType(reference.getPropertyName());
                                    final Collection<Object> resultCollection = ReflectionUtils.getCollection(collectionType);
                                    for (Object foreignEntity : originalCollection) {
                                        if (foreignEntity == null) {
                                            resultCollection.add(null);
                                            continue;
                                        }
                                        resultCollection.add(dataAccess.save(foreignEntity));
                                    }
                                    wrapper.setPropertyValue(reference.getPropertyName(), resultCollection);
                                } catch (Exception e) {
                                    throw new EntityDefinitionError("Failed to cascade save property " + reference.getPropertyName(), e);
                                }
                            }
                        }
                );
    }

    @Override
    public Map<TableMetadata<?>, Set<ManyToManyMiddleEntity>> getManyToManyRelatedObjects(final E entity) {
        final HashMap<TableMetadata<?>, Set<ManyToManyMiddleEntity>> map = new HashMap<TableMetadata<?>, Set<ManyToManyMiddleEntity>>();
        final BeanAccessor<E> accessor = new MethodBeanAccessor<E>(entity);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .keep(new Filter<RelationMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(RelationMetadata<E, ?> item) {
                        return item.getCascadeMetadata().cascadePersist() && RelationType.MANY_TO_MANY.equals(item.getType());
                    }
                })
                .each(new Processor<RelationMetadata<E, ?>>() {
                    @Override
                    public void process(RelationMetadata<E, ?> input) {
                        final TableMetadata<?> foreignTable = input.getForeignTable();
                        try {
                            Object propertyValue = accessor.getPropertyValue(input.getPropertyName());
                            if (propertyValue == null) {
                                propertyValue = Collections.emptyList();
                            }
                            //noinspection unchecked
                            final Collection<Object> collection = (Collection<Object>) propertyValue;
                            final ColumnNameFilter columnNameFilter = new ColumnNameFilter(tableMetadata.getName());
                            if (collection.isEmpty()) {
                                final ManyToManyMiddleEntity middleEntity = new ManyToManyMiddleEntity();
                                final BeanWrapper<ManyToManyMiddleEntity> wrapper = new MethodBeanWrapper<ManyToManyMiddleEntity>(middleEntity);
                                wrapper.setPropertyValue(with(foreignTable.getColumns()).find(columnNameFilter).getPropertyName(), entity);
                                map.put(foreignTable, new HashSet<ManyToManyMiddleEntity>(Arrays.asList(middleEntity)));
                                return;
                            }
                            final Set<ManyToManyMiddleEntity> entities = new HashSet<ManyToManyMiddleEntity>();
                            for (Object item : collection) {
                                final ManyToManyMiddleEntity middleEntity = new ManyToManyMiddleEntity();
                                final BeanWrapper<ManyToManyMiddleEntity> wrapper = new MethodBeanWrapper<ManyToManyMiddleEntity>(middleEntity);
                                wrapper.setPropertyValue(with(foreignTable.getColumns()).find(columnNameFilter).getPropertyName(), entity);
                                wrapper.setPropertyValue(with(foreignTable.getColumns()).find(new NegatingFilter<ColumnMetadata>(columnNameFilter)).getPropertyName(), item);
                                middleEntity.setRelationMetadata(input);
                                entities.add(middleEntity);
                            }
                            map.put(foreignTable, entities);
                        } catch (Exception e) {
                            throw new UnsuccessfulOperationError("Failed to determine intermediary relation", e);
                        }
                    }
                });
        return map;
    }

    @Override
    public void incrementVersion(E entity) {
        final ColumnMetadata versionColumn = tableMetadata.getVersionColumn();
        if (!isLockable()) {
            return;
        }
        final BeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        try {
            Object version = wrapper.getPropertyValue(versionColumn.getPropertyName());
            if (version == null) {
                return;
            }
            final Class<?> versionType = ReflectionUtils.mapType(versionColumn.getPropertyType());
            if (Long.class.isAssignableFrom(versionType)) {
                version = ((Long) version + 1L);
            } else if (Integer.class.isAssignableFrom(versionType)) {
                version = ((Integer) version + 1);
            } else if (Short.class.isAssignableFrom(versionType)) {
                version = ((Short) version + 1);
            } else if (Types.TIMESTAMP == versionColumn.getType()) {
                version = new Timestamp(new Date().getTime());
            } else {
                throw new VersionColumnDefinitionError("Unsupported version type: " + versionType.getCanonicalName());
            }
            wrapper.setPropertyValue(versionColumn.getPropertyName(), version);
        } catch (Exception e) {
            throw new EntityDefinitionError("Version property has not been properly defined", e);
        }
    }

    @Override
    public void initializeVersion(E entity) {
        final ColumnMetadata versionColumn = tableMetadata.getVersionColumn();
        if (!isLockable()) {
            return;
        }
        final BeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        try {
            Object version;
            final Class<?> versionType = ReflectionUtils.mapType(versionColumn.getPropertyType());
            if (Long.class.isAssignableFrom(versionType)) {
                version = 0L;
            } else if (Integer.class.isAssignableFrom(versionType)) {
                version = 0;
            } else if (Short.class.isAssignableFrom(versionType)) {
                version = 0;
            } else if (Types.TIMESTAMP == versionColumn.getType()) {
                version = new Timestamp(new Date().getTime());
            } else {
                throw new VersionColumnDefinitionError("Unsupported version type: " + versionType.getCanonicalName());
            }
            wrapper.setPropertyValue(versionColumn.getPropertyName(), version);
        } catch (Exception e) {
            throw new VersionColumnDefinitionError("Version property has not been properly defined", e);
        }
    }

    @Override
    public boolean isLockable() {
        return tableMetadata.getVersionColumn() != null;
    }

    @Override
    public Serializable getVersion(E entity) {
        if (!isLockable()) {
            return null;
        }
        final ColumnMetadata versionColumn = tableMetadata.getVersionColumn();
        final BeanWrapper<E> accessor = new MethodBeanWrapper<E>(entity);
        try {
            if (accessor.hasProperty(versionColumn.getPropertyName()) && accessor.isReadable(versionColumn.getPropertyName())) {
                return (Serializable) accessor.getPropertyValue(versionColumn.getPropertyName());
            } else {
                return null;
            }
        } catch (Exception e) {
            throw new VersionColumnDefinitionError("Failed to access version property", e);
        }
    }

    @Override
    public void setVersion(E entity, Serializable version) {
        if (!isLockable()) {
            return;
        }
        final ColumnMetadata versionColumn = tableMetadata.getVersionColumn();
        final BeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        try {
            if (wrapper.hasProperty(versionColumn.getPropertyName()) && wrapper.isWritable(versionColumn.getPropertyName())) {
                wrapper.setPropertyValue(versionColumn.getPropertyName(), version);
            }
        } catch (Exception e) {
            throw new VersionColumnDefinitionError("Failed to access version property", e);
        }
    }

}
