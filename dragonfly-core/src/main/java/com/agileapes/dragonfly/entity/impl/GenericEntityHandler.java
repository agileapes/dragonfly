package com.agileapes.dragonfly.entity.impl;

import com.agileapes.couteau.basics.api.Filter;
import com.agileapes.couteau.basics.api.Processor;
import com.agileapes.couteau.reflection.beans.BeanAccessor;
import com.agileapes.couteau.reflection.beans.BeanWrapper;
import com.agileapes.couteau.reflection.beans.impl.MethodBeanAccessor;
import com.agileapes.couteau.reflection.beans.impl.MethodBeanWrapper;
import com.agileapes.couteau.reflection.error.NoSuchPropertyException;
import com.agileapes.couteau.reflection.property.WritePropertyAccessor;
import com.agileapes.dragonfly.data.DataAccess;
import com.agileapes.dragonfly.entity.EntityContext;
import com.agileapes.dragonfly.entity.EntityHandler;
import com.agileapes.dragonfly.entity.EntityInitializationContext;
import com.agileapes.dragonfly.error.EntityDefinitionError;
import com.agileapes.dragonfly.error.EntityPreparationError;
import com.agileapes.dragonfly.error.NoPrimaryKeyDefinedError;
import com.agileapes.dragonfly.metadata.ColumnMetadata;
import com.agileapes.dragonfly.metadata.ReferenceMetadata;
import com.agileapes.dragonfly.metadata.TableMetadata;
import com.agileapes.dragonfly.metadata.ValueGenerationType;
import com.agileapes.dragonfly.metadata.impl.PrimaryKeyConstraintMetadata;
import com.agileapes.dragonfly.tools.ColumnPropertyFilter;

import java.io.Serializable;
import java.util.*;
import java.util.concurrent.*;

import static com.agileapes.couteau.basics.collections.CollectionWrapper.with;

/**
 * @author Mohammad Milad Naseri (m.m.naseri@gmail.com)
 * @since 1.0 (2013/9/18, 15:28)
 */
public class GenericEntityHandler<E> implements EntityHandler<E> {

    private final Class<E> entityType;
    private final DefaultEntityMapCreator mapCreator;
    private final DefaultMapEntityCreator entityCreator;
    private final EntityContext entityContext;
    private final TableMetadata<E> tableMetadata;
    private boolean keyAutoGenerated;
    private boolean hasPrimaryKey;
    private String keyProperty;

    public GenericEntityHandler(Class<E> entityType, EntityContext entityContext, TableMetadata<E> tableMetadata) {
        this.entityType = entityType;
        this.entityContext = entityContext;
        this.tableMetadata = tableMetadata;
        mapCreator = new DefaultEntityMapCreator();
        entityCreator = new DefaultMapEntityCreator();
        hasPrimaryKey = this.tableMetadata.hasPrimaryKey();
        if (hasPrimaryKey) {
            final PrimaryKeyConstraintMetadata primaryKey = this.tableMetadata.getPrimaryKey();
            if (primaryKey.getColumns().size() != 1) {
                hasPrimaryKey = false;
            } else {
                final ColumnMetadata columnMetadata = primaryKey.getColumns().iterator().next();
                keyProperty = columnMetadata.getPropertyName();
                keyAutoGenerated = ValueGenerationType.AUTO.equals(columnMetadata.getGenerationType());
            }
        }
    }

    @Override
    public Class<E> getEntityType() {
        return entityType;
    }

    @Override
    public Map<String, Object> toMap(E entity) {
        return mapCreator.toMap(tableMetadata, entity);
    }

    @Override
    public E fromMap(E entity, final Map<String, Object> map) {
        return entityCreator.fromMap(entity, tableMetadata.getColumns(), map);
    }

    @Override
    public Serializable getKey(E entity) {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        try {
            return new MethodBeanAccessor<E>(entity).getPropertyValue(keyProperty, Serializable.class);
        } catch (Exception e) {
            return null;
        }
    }

    @Override
    public void setKey(E entity, Serializable key) {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        try {
            new MethodBeanWrapper<E>(entity).setPropertyValue(keyProperty, key);
        } catch (Exception e) {
            throw new EntityDefinitionError("Failed to set key on entity " + entityType, e);
        }
    }

    @Override
    public boolean hasKey() {
        return hasPrimaryKey;
    }

    @Override
    public boolean isKeyAutoGenerated() {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        return keyAutoGenerated;
    }

    @Override
    public void copy(E original, E copy) {
        final BeanAccessor<E> reader = new MethodBeanAccessor<E>(original);
        final BeanWrapper<E> writer = new MethodBeanWrapper<E>(copy);
        //noinspection unchecked
        with(reader.getPropertyNames())
                .keep(new Filter<String>() {
                    @Override
                    public boolean accepts(String item) {
                        try {
                            return writer.isWritable(item);
                        } catch (NoSuchPropertyException e) {
                            return false;
                        }
                    }
                })
                .each(new Processor<String>() {
                    @Override
                    public void process(String input) {
                        try {
                            writer.setPropertyValue(input, reader.getPropertyValue(input));
                        } catch (Exception ignored) {
                        }
                    }
                });
    }

    @Override
    public String getKeyProperty() {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        return keyProperty;
    }

    @Override
    public void loadRelations(final E entity, final Map<String, Object> values, final EntityInitializationContext initializationContext) {
        final MethodBeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .drop(new Filter<ReferenceMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(ReferenceMetadata<E, ?> item) {
                        return item.isLazy();
                    }
                })
                .forThose(new Filter<ReferenceMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(ReferenceMetadata<E, ?> reference) {
                                  return reference.isRelationOwner() && reference.getRelationType().getForeignCardinality() == 1;
                              }
                          },
                        new Processor<ReferenceMetadata<E, ?>>() {
                            @Override
                            public void process(final ReferenceMetadata<E, ?> reference) {
                                final ColumnMetadata columnMetadata = with(reference.getLocalTable().getColumns()).find(new ColumnPropertyFilter(reference.getPropertyName()));
                                final String columnName = with(values.keySet()).find(new Filter<String>() {
                                    @Override
                                    public boolean accepts(String item) {
                                        return item.equalsIgnoreCase(columnMetadata.getName());
                                    }
                                });
                                final Object foreignKey = values.get(columnName);
                                final Object foreignEntity = initializationContext.get(reference.getForeignTable().getEntityType(), (Serializable) foreignKey);
                                try {
                                    wrapper.setPropertyValue(reference.getPropertyName(), foreignEntity);
                                } catch (Exception e) {
                                    throw new EntityPreparationError("Could not set relation property " + reference.getLocalTable().getEntityType().getCanonicalName() + "." + reference.getPropertyName(), e);
                                }
                            }
                        }
                )
                .forThose(new Filter<ReferenceMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(ReferenceMetadata<E, ?> reference) {
                                  return !reference.isRelationOwner() && reference.getRelationType().getLocalCardinality() == 1;
                              }
                          }, new Processor<ReferenceMetadata<E, ?>>() {
                              @Override
                              public void process(ReferenceMetadata<E, ?> reference) {
                                  final Object foreignEntity = entityContext.getInstance(reference.getForeignTable().getEntityType());
                                  final MethodBeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                                  try {
                                      foreignEntityWrapper.setPropertyValue(reference.getForeignColumn().getPropertyName(), entity);
                                  } catch (Exception e) {
                                      throw new EntityPreparationError("Could not set relation property " + reference.getForeignTable().getEntityType().getCanonicalName() + "." + reference.getForeignColumn().getPropertyName(), e);
                                  }
                                  final List<Object> objects = initializationContext.getDataAccess().find(foreignEntity);
                                  final Object propertyValue;
                                  if (reference.getRelationType().getForeignCardinality() == 1) {
                                      if (objects.isEmpty()) {
                                          return;
                                      } else if (objects.size() > 1) {
                                          throw new EntityDefinitionError("More than one item corresponds to one-to-one relationship");
                                      }
                                      propertyValue = objects.get(0);
                                  } else {
                                      try {
                                          propertyValue = getCollection(wrapper.getPropertyType(reference.getPropertyName()));
                                      } catch (NoSuchPropertyException e) {
                                          throw new EntityDefinitionError("Failed to get property type " + reference.getLocalTable().getEntityType().getCanonicalName() + "." + reference.getPropertyName());
                                      }
                                      //noinspection unchecked
                                      ((Collection<Object>) propertyValue).addAll(objects);
                                  }
                                  try {
                                      wrapper.setPropertyValue(reference.getPropertyName(), propertyValue);
                                  } catch (Exception e) {
                                      throw new EntityPreparationError("Could not set relation property " + reference.getLocalTable().getEntityType().getCanonicalName() + "." + reference.getPropertyName(), e);
                                  }
                              }
                          }
                );
    }

    @Override
    public void deleteDependentRelations(final E entity, final DataAccess dataAccess) {
        final MethodBeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .keep(new Filter<ReferenceMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(ReferenceMetadata<E, ?> item) {
                        return item.getCascadeMetadata().cascadeRemove();
                    }
                })
                .forThose(new Filter<ReferenceMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(ReferenceMetadata<E, ?> item) {
                                  return item.isRelationOwner();
                              }
                          }, new Processor<ReferenceMetadata<E, ?>>() {
                              @Override
                              public void process(ReferenceMetadata<E, ?> reference) {
                                  //many-to-one, owner=here and one-to-one, owner=here
                                  try {
                                      final Object foreignEntity = wrapper.getPropertyValue(reference.getPropertyName());
                                      if (foreignEntity == null) {
                                          return;
                                      }
                                      dataAccess.delete(foreignEntity);
                                  } catch (Exception e) {
                                      throw new EntityDefinitionError("Could not access foreign property", e);
                                  }
                              }
                          }
                );
    }

    @Override
    public void deleteDependencyRelations(final E entity, final DataAccess dataAccess) {
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .keep(new Filter<ReferenceMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(ReferenceMetadata<E, ?> item) {
                        return item.getCascadeMetadata().cascadeRemove();
                    }
                })
                .forThose(new Filter<ReferenceMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(ReferenceMetadata<E, ?> item) {
                                  return !item.isRelationOwner();
                              }
                          },
                        new Processor<ReferenceMetadata<E, ?>>() {
                            @Override
                            public void process(ReferenceMetadata<E, ?> reference) {
                                //one-to-many, owner=there and one-to-one, owner=there
                                final Object foreignEntity = entityContext.getInstance(reference.getForeignTable().getEntityType());
                                final MethodBeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                                try {
                                    //noinspection unchecked
                                    final WritePropertyAccessor<Object> writer = (WritePropertyAccessor<Object>) foreignEntityWrapper.getPropertyWriter(reference.getForeignColumn().getPropertyName());
                                    writer.setPropertyValue(entity);
                                } catch (Exception e) {
                                    throw new EntityDefinitionError("Failed to access property", e);
                                }
                                dataAccess.delete(foreignEntity);
                            }
                        }
                );
    }

    @Override
    public void saveDependencyRelations(E entity, final DataAccess dataAccess) {
        final MethodBeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .keep(new Filter<ReferenceMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(ReferenceMetadata<E, ?> item) {
                        return item.getCascadeMetadata().cascadePersist() && item.isRelationOwner();
                    }
                })
                .forThose(new Filter<ReferenceMetadata<E, ?>>() {
                              //many-to-one and one-to-one relations where owner=here
                              @Override
                              public boolean accepts(ReferenceMetadata<E, ?> item) {
                                  return item.getRelationType().getForeignCardinality() == 1;
                              }
                          },
                        new Processor<ReferenceMetadata<E, ?>>() {
                            @Override
                            public void process(ReferenceMetadata<E, ?> input) {
                                try {
                                    final Object foreignEntity = wrapper.getPropertyValue(input.getPropertyName());
                                    if (foreignEntity == null) {
                                        return;
                                    }
                                    wrapper.setPropertyValue(input.getPropertyName(), dataAccess.save(foreignEntity));
                                } catch (Exception e) {
                                    throw new EntityDefinitionError("Failed to access property " + input.getLocalTable().getEntityType().getCanonicalName() + "." + input.getPropertyName(), e);
                                }
                            }
                        }
                );
    }

    @Override
    public void saveDependentRelations(final E entity, final DataAccess dataAccess) {
        final MethodBeanWrapper<E> wrapper = new MethodBeanWrapper<E>(entity);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .keep(new Filter<ReferenceMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(ReferenceMetadata<E, ?> item) {
                        return item.getCascadeMetadata().cascadePersist() && !item.isRelationOwner();
                    }
                })
                .drop(new Filter<ReferenceMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(ReferenceMetadata<E, ?> item) {
                        //for now we drop many-to-many relations
                        return item.getRelationType().getLocalCardinality() > 1;
                    }
                })
                .forThose(new Filter<ReferenceMetadata<E, ?>>() {
                              //one-to-one relations
                              @Override
                              public boolean accepts(ReferenceMetadata<E, ?> item) {
                                  return item.getRelationType().getForeignCardinality() == 1;
                              }
                          },
                        new Processor<ReferenceMetadata<E, ?>>() {
                            @Override
                            public void process(ReferenceMetadata<E, ?> input) {
                                try {
                                    final Object foreignEntity = wrapper.getPropertyValue(input.getPropertyName());
                                    if (foreignEntity == null) {
                                        return;
                                    }
                                    final MethodBeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                                    foreignEntityWrapper.setPropertyValue(input.getForeignColumn().getPropertyName(), entity);
                                    dataAccess.delete(foreignEntity);
                                    wrapper.setPropertyValue(input.getPropertyName(), dataAccess.save(foreignEntity));
                                } catch (Exception e) {
                                    throw new EntityDefinitionError("Failed to access property " + input.getLocalTable().getEntityType().getCanonicalName() + "." + input.getPropertyName(), e);
                                }
                            }
                        }
                )
                .forThose(new Filter<ReferenceMetadata<E, ?>>() {
                              @Override
                              public boolean accepts(ReferenceMetadata<E, ?> item) {
                                  //one-to-many
                                  return item.getRelationType().getForeignCardinality() > 1;
                              }
                          },
                        new Processor<ReferenceMetadata<E, ?>>() {
                            @Override
                            public void process(ReferenceMetadata<E, ?> input) {
                                try {
                                    final Object propertyValue = wrapper.getPropertyValue(input.getPropertyName());
                                    if (propertyValue == null) {
                                        return;
                                    }
                                    //noinspection unchecked
                                    final Collection<Object> originalCollection = (Collection<Object>) propertyValue;
                                    final Collection<Object> newCollection = getCollection(originalCollection.getClass());
                                    for (Object foreignEntity : originalCollection) {
                                        if (foreignEntity == null) {
                                            newCollection.add(null);
                                            continue;
                                        }
                                        final MethodBeanWrapper<Object> foreignEntityWrapper = new MethodBeanWrapper<Object>(foreignEntity);
                                        foreignEntityWrapper.setPropertyValue(input.getForeignColumn().getPropertyName(), entity);
                                        dataAccess.delete(foreignEntity);
                                        newCollection.add(dataAccess.save(foreignEntity));
                                    }
                                    wrapper.setPropertyValue(input.getPropertyName(), newCollection);
                                } catch (Exception e) {
                                    throw new EntityDefinitionError("Failed to access property " + input.getLocalTable().getEntityType().getCanonicalName() + "." + input.getPropertyName(), e);
                                }
                            }
                        }
                );
    }

    private Collection<Object> getCollection(Class<?> propertyType) {
        if (!Collection.class.isAssignableFrom(propertyType)) {
            throw new EntityDefinitionError("Expected property to be a collection while it was " + propertyType.getCanonicalName());
        }
        if (Set.class.isAssignableFrom(propertyType)) {
            if (TreeSet.class.isAssignableFrom(propertyType)) {
                return new TreeSet<Object>();
            } else if (ConcurrentSkipListSet.class.isAssignableFrom(propertyType)) {
                return new ConcurrentSkipListSet<Object>();
            } else if (CopyOnWriteArraySet.class.isAssignableFrom(propertyType)) {
                return new CopyOnWriteArraySet<Object>();
            }
            return new HashSet<Object>();
        } else if (List.class.isAssignableFrom(propertyType)) {
            if (LinkedList.class.isAssignableFrom(propertyType)) {
                return new LinkedList<Object>();
            } else if (CopyOnWriteArrayList.class.isAssignableFrom(propertyType)) {
                return new CopyOnWriteArrayList<Object>();
            }
            return new ArrayList<Object>();
        } else if (Queue.class.isAssignableFrom(propertyType)) {
            if (ConcurrentLinkedQueue.class.isAssignableFrom(propertyType)) {
                return new ConcurrentLinkedQueue<Object>();
            } else if (PriorityQueue.class.isAssignableFrom(propertyType)) {
                return new PriorityQueue<Object>();
            } else if (ConcurrentLinkedQueue.class.isAssignableFrom(propertyType)) {
                return new ConcurrentLinkedQueue<Object>();
            } else if (LinkedBlockingQueue.class.isAssignableFrom(propertyType)) {
                return new LinkedBlockingQueue<Object>();
            } else if (SynchronousQueue.class.isAssignableFrom(propertyType)) {
                return new SynchronousQueue<Object>();
            } else if (PriorityBlockingQueue.class.isAssignableFrom(propertyType)) {
                return new PriorityBlockingQueue<Object>();
            }
            return new PriorityQueue<Object>();
        } else {
            throw new UnsupportedOperationException("Cannot instantiate a collection of type " + propertyType.getCanonicalName());
        }
    }

}
