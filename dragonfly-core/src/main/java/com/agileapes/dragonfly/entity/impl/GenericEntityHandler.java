package com.agileapes.dragonfly.entity.impl;

import com.agileapes.couteau.basics.api.Filter;
import com.agileapes.couteau.basics.api.Processor;
import com.agileapes.couteau.basics.api.Transformer;
import com.agileapes.couteau.basics.api.impl.NullFilter;
import com.agileapes.couteau.reflection.beans.BeanAccessor;
import com.agileapes.couteau.reflection.beans.BeanWrapper;
import com.agileapes.couteau.reflection.beans.impl.MethodBeanAccessor;
import com.agileapes.couteau.reflection.beans.impl.MethodBeanWrapper;
import com.agileapes.couteau.reflection.error.NoSuchPropertyException;
import com.agileapes.couteau.reflection.error.PropertyAccessException;
import com.agileapes.couteau.reflection.error.PropertyTypeMismatchException;
import com.agileapes.dragonfly.entity.EntityContext;
import com.agileapes.dragonfly.entity.EntityHandler;
import com.agileapes.dragonfly.entity.EntityInitializationContext;
import com.agileapes.dragonfly.error.EntityDefinitionError;
import com.agileapes.dragonfly.error.NoPrimaryKeyDefinedError;
import com.agileapes.dragonfly.metadata.*;
import com.agileapes.dragonfly.metadata.impl.PrimaryKeyConstraintMetadata;
import com.agileapes.dragonfly.tools.ColumnPropertyFilter;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;

import static com.agileapes.couteau.basics.collections.CollectionWrapper.with;

/**
 * @author Mohammad Milad Naseri (m.m.naseri@gmail.com)
 * @since 1.0 (2013/9/18, 15:28)
 */
public class GenericEntityHandler<E> implements EntityHandler<E> {

    private final Class<E> entityType;
    private final DefaultEntityMapCreator mapCreator;
    private final DefaultMapEntityCreator entityCreator;
    private final TableMetadata<E> tableMetadata;
    private boolean keyAutoGenerated;
    private boolean hasPrimaryKey;
    private String keyProperty;

    public GenericEntityHandler(Class<E> entityType, EntityContext entityContext, TableMetadata<E> tableMetadata) {
        this.entityType = entityType;
        this.tableMetadata = tableMetadata;
        mapCreator = new DefaultEntityMapCreator();
        entityCreator = new DefaultMapEntityCreator(entityContext);
        hasPrimaryKey = this.tableMetadata.hasPrimaryKey();
        if (hasPrimaryKey) {
            final PrimaryKeyConstraintMetadata primaryKey = this.tableMetadata.getPrimaryKey();
            if (primaryKey.getColumns().size() != 1) {
                hasPrimaryKey = false;
            } else {
                final ColumnMetadata columnMetadata = primaryKey.getColumns().iterator().next();
                keyProperty = columnMetadata.getPropertyName();
                keyAutoGenerated = ValueGenerationType.AUTO.equals(columnMetadata.getGenerationType());
            }
        }
    }

    @Override
    public Class<E> getEntityType() {
        return entityType;
    }

    @Override
    public Map<String, Object> toMap(E entity) {
        return mapCreator.toMap(tableMetadata, entity);
    }

    @Override
    public E fromMap(E entity, final Map<String, Object> map, final EntityInitializationContext initializationContext) {
        final E result = entityCreator.fromMap(tableMetadata, map, initializationContext);
        final BeanWrapper<E> wrapper = new MethodBeanWrapper<E>(result);
        //noinspection unchecked
        with(tableMetadata.getForeignReferences())
                .drop(new Filter<ReferenceMetadata<E, ?>>() {
                    @Override
                    public boolean accepts(ReferenceMetadata<E, ?> item) {
                        return item.isLazy() || !item.isRelationOwner() || item.getRelationType().getForeignCardinality() > 1;
                    }
                })
                .transform(new Transformer<ReferenceMetadata<E, ?>, ColumnMetadata>() {
                    @Override
                    public ColumnMetadata map(ReferenceMetadata<E, ?> reference) {
                        return with(reference.getLocalTable().getColumns()).find(new ColumnPropertyFilter(reference.getPropertyName()));
                    }
                })
                .drop(new NullFilter<ColumnMetadata>())
                .each(new Processor<ColumnMetadata>() {
                    @Override
                    public void process(ColumnMetadata input) {
                        try {
                            wrapper.setPropertyValue(input.getPropertyName(), initializationContext.get(input.getPropertyType(), (Serializable) map.get(input.getName())));
                        } catch (Exception e) {
                            throw new EntityDefinitionError("Entity definition is corrupted as the proper way of injecting dependencies cannot be deduced", e);
                        }
                    }
                });
        return result;
    }

    @Override
    public Serializable getKey(E entity) {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        try {
            return new MethodBeanAccessor<E>(entity).getPropertyValue(keyProperty, Serializable.class);
        } catch (Exception e) {
            return null;
        }
    }

    @Override
    public void setKey(E entity, Serializable key) {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        try {
            new MethodBeanWrapper<E>(entity).setPropertyValue(keyProperty, key);
        } catch (Exception ignored) {
        }
    }

    @Override
    public boolean hasKey() {
        return hasPrimaryKey;
    }

    @Override
    public boolean isKeyAutoGenerated() {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        return keyAutoGenerated;
    }

    @Override
    public void copy(E original, E copy) {
        final BeanAccessor<E> reader = new MethodBeanAccessor<E>(original);
        final BeanWrapper<E> writer = new MethodBeanWrapper<E>(copy);
        //noinspection unchecked
        with(reader.getPropertyNames())
                .keep(new Filter<String>() {
                    @Override
                    public boolean accepts(String item) {
                        try {
                            return writer.isWritable(item);
                        } catch (NoSuchPropertyException e) {
                            return false;
                        }
                    }
                })
                .each(new Processor<String>() {
                    @Override
                    public void process(String input) {
                        try {
                            writer.setPropertyValue(input, reader.getPropertyValue(input));
                        } catch (Exception ignored) {
                        }
                    }
                });
    }

    @Override
    public String getKeyProperty() {
        if (!hasKey()) {
            throw new NoPrimaryKeyDefinedError(entityType);
        }
        return keyProperty;
    }

    @Override
    public Collection<?> getRelatedItems(E entity, Filter<CascadeMetadata> cascadeMetadataFilter) {
        final ArrayList<Object> result = new ArrayList<Object>();
        final BeanAccessor<E> accessor = new MethodBeanAccessor<E>(entity);
        for (ReferenceMetadata<E, ?> referenceMetadata : tableMetadata.getForeignReferences()) {
            if (referenceMetadata.isRelationOwner()) {
                continue;
            }
            if (!referenceMetadata.getDeclaringClass().isInstance(entity)) {
                continue;
            }
            if (!cascadeMetadataFilter.accepts(referenceMetadata.getCascadeMetadata())) {
                continue;
            }
            final Object propertyValue;
            try {
                propertyValue = accessor.getPropertyValue(referenceMetadata.getPropertyName());
            } catch (NoSuchPropertyException ignored) {
                continue;
            } catch (PropertyAccessException e) {
                throw new EntityDefinitionError("Error accessing entity property " + referenceMetadata.getDeclaringClass().getCanonicalName() + "." + referenceMetadata.getPropertyName(), e);
            }
            final Collection<Object> objects = new HashSet<Object>();
            if (referenceMetadata.getRelationType().getForeignCardinality() > 1) {
                objects.addAll((Collection<?>) propertyValue);
            } else {
                objects.add(propertyValue);
            }
            for (Object object : objects) {
                if (object == null) {
                    continue;
                }
                final BeanWrapper<Object> wrapper = new MethodBeanWrapper<Object>(object);
                try {
                    wrapper.setPropertyValue(referenceMetadata.getForeignColumn().getPropertyName(), entity);
                } catch (NoSuchPropertyException e) {
                    throw new EntityDefinitionError("Property not found", e);
                } catch (PropertyAccessException e) {
                    throw new EntityDefinitionError("Property access error", e);
                } catch (PropertyTypeMismatchException e) {
                    throw new EntityDefinitionError("Could not match property type to local entity", e);
                }
                result.add(object);
            }
        }
        return result;
    }

}
